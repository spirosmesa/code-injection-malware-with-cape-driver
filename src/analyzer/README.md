# The Analyzer

This directory contains the main source code for the referene implementation of the execution trace analyzer, as well as all behavior specifications (graphs) that were used in the original research.

## How To Build

-   Ensure you have .NET 6.0 or higher installed. See [official installation instructions](https://dotnet.microsoft.com/en-us/download/dotnet/6.0).

-   Build using your favorite IDE such as Visual Studio or JetBrains Rider, or run the following command:

    ```
    $ dotnet build -c Release
    ```

  This will create a `bin/` directory with all the built artifacts.


## How To Run

Navigate to the artifacts directory and simply run either `Analyzer` or `Analyzer.exe` depending on whether you built on *nix or Windows.

### Examples:

Below some example commands you can use.
Use `--help` to get extended information on the different commands available.


-   Analyze a single file:
    
    ```
    $ ./Analyzer analyze path/to/sample.exe
    ```

-   Analyze an entire folder of samples:

    ```
    $ ./Analyzer analyze -r path/to/folder/
    ```

-   Change execution and analysis timeouts to 6 minutes execution time, 10 minute analysis time:

    ```
    $ ./Analyzer analyze path/to/sample.exe --execution-timeout 6 --analysis-timeout 10
    ```

-   Analyze an entire folder of samples using 4 threads in parallel (note, the back-end sandbox has to support this for this to be effective):

    ```
    $ ./Analyzer analyze -r path/to/folder/ --parallel 4
    ```

-   Analyze a log from a previously ran sample:

    ```
    $ ./Analyzer log-analyze path/to/log/file/or/directory
    ```

-   Analyze multiple logs from multiple previously ran samples in a directory:

    ```
    $ ./Analyzer log-analyze -r path/to/log/directories
    ```


## Backing Drivers

The reference implementation uses the [DRAKVUF Sandbox](drakvuf-sandbox.readthedocs.io/) as a default backing driver, and assumes the `DRAKVUF_HOST` environment variable to be set to the hostname pointing to the DRAKVUF sandbox instance. 
If this variable is not set, `http://localhost:6300/` is assumed as host.

Other drivers (such as Cuckoo or CAPE sandbox) can be added by implementing the `Analyzer.Data.IExecutionDriver` interface, and registering it in the `drivers.json` configuration file of the main `Analyzer` program.

If you do not have access to DRAKVUF or another custom backend, you are limited to analyzing their log files only.


## Defining your own behaviors

The Analyzer is not necessarily limited to detecting code injection techniques only. 
Other types of behaviors can be specified and imported into the program by going to the `Behaviors` directory in the output folder.
The Analyzer will automatically try and parse any `.behavior` file and include it in its analyses.
The syntax used in `.behavior` files is similar to the DOT GraphViz language, with a few extensions. 

Below is an example behavior specification of the Shell Injection technique.
It defines 4 places `process_handle`, `allocated`, `written`, and `done`.
The last place is defined to be `accepting`, indicating a final place that tokens in the petri net should reach to consider the behavior to be recognized.

Inside transition blocks we can define an API to match on, together with the parameters and additional constraints.
Extra constraints can be put in a `where` clause and support a very basic syntax:
- Arithmetic operators: `+`, `-`, `/`, `*`. `%`,
- Bitwise operators: `~`, `&`, `|`, `^`,
- Relational operators: `==`, `!=`, `>`, `>=`, `<`, `<=`
- Boolean operators: `and`, `or`, `true`, `false`
- Collection operators: `in`, `[start..end]`

Integers are assumed in decimal by default, but can be written in hexadecimal 
notation as well with the `0x` specifier.
Strings follow the basic string rules and escaping from C-like languages.
A `_` indicates the parameter is ignored.

Finally, drawing edges is similar to how this would be done in DOT GraphViz with arrows (`->`).

```dot
behavior "Generic Shell Injection" {
    place [
        process_handle 
        allocated 
        written
    ]
    place done accepting

    transition t0 {
        NtOpenProcess(handle, _, _, _)
    }

    transition t1 {
        NtCreateUserProcess(handle, _, _, _, _, _, _, _, _, _, _)
    }
    
    transition t2 {
        NtAllocateVirtualMemory(handle, allocAddress, _, allocSize, _, _)
    }

    transition t3 {
        NtWriteVirtualMemory(handle, writeAddress, _, _, _)
        where
            writeAddress in [allocAddress..(allocAddress + allocSize)]
    }

    transition t4 {
        CreateRemoteThread(handle, _, _, startAddress, _, _, _)
        where
            startAddress in [allocAddress..(allocAddress + allocSize)]
    }

    transition t5 {
        NtCreateThreadEx(_, _, _, handle, startAddress, _, _, _, _, _, _)
        where
            startAddress in [allocAddress..(allocAddress + allocSize)]
    }

    t0 -> process_handle
    t1 -> process_handle
    process_handle -> t2 -> allocated -> t3 -> written
    
    written -> t4 -> done
    written -> t5 -> done
}
```