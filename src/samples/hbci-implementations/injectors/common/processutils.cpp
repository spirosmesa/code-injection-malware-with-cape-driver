#include "pch.h"
#include "processutils.h"
#include <stdio.h>
#include <TlHelp32.h>
#include <stdlib.h>

COMMONUTILS_API DWORD FindProcessIdByName(const wchar_t* name)
{
	auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (snapshot == INVALID_HANDLE_VALUE)
		return 0;

	PROCESSENTRY32 entry = {};
	entry.dwSize = sizeof(PROCESSENTRY32);

	if (!Process32First(snapshot, &entry))
	{
		CloseHandle(snapshot);
		return 0;
	}
	
	DWORD result = 0;
	do
	{
		if (lstrcmpW(name, entry.szExeFile) == 0) {
			result = entry.th32ProcessID;
		}
	} while (result == 0 && Process32Next(snapshot, &entry));

	CloseHandle(snapshot);
	return result;
}

COMMONUTILS_API HANDLE OpenProcessByName(const wchar_t* name)
{
	DWORD id = FindProcessIdByName(name);
	if (id == 0)
		return INVALID_HANDLE_VALUE;

	return OpenProcess(PROCESS_ALL_ACCESS, false, id);
}


COMMONUTILS_API SIZE_T FindAlertableThreads(HANDLE processHandle, DWORD pid, PHANDLE buffer, SIZE_T bufferSize)
{
    HANDLE sourceHandles[MAXIMUM_WAIT_OBJECTS] = {};
    HANDLE targetHandles[MAXIMUM_WAIT_OBJECTS] = {};
    HANDLE threadHandles[MAXIMUM_WAIT_OBJECTS] = {};

    // 1. Enumerate threads in target process
    auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (snapshot == INVALID_HANDLE_VALUE)
        return NULL;

    THREADENTRY32 entry;
    entry.dwSize = sizeof(THREADENTRY32);
    int threadCount = 0;

    if (!Thread32First(snapshot, &entry))
        return NULL;

    do
    {
        // if not our target process, skip it
        if (entry.th32OwnerProcessID != pid)
            continue;

        // if we can't open thread, skip it
        auto threadHandle = OpenThread(
            THREAD_ALL_ACCESS,
            FALSE,
            entry.th32ThreadID);

        if (threadHandle == NULL)
            continue;

        // otherwise, add to list
        threadHandles[threadCount++] = threadHandle;

        // if we've reached MAXIMUM_WAIT_OBJECTS. break
        if (threadCount == MAXIMUM_WAIT_OBJECTS)
            break;
    } while (Thread32Next(snapshot, &entry));

    // Resolve address of SetEvent
    auto setEvent = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "SetEvent");

    for (int i = 0; i < threadCount; i++)
    {
        // 2. create event and duplicate in target process
        sourceHandles[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!DuplicateHandle(
            GetCurrentProcess(),
            sourceHandles[i],
            processHandle,
            &targetHandles[i],
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS))
        {
            PrintLastError("DuplicateHandle");
            return 0;
        }

        if (!QueueUserAPC((PAPCFUNC)setEvent, threadHandles[i], (ULONG_PTR)targetHandles[i]))
        {
            PrintLastError("QueueUserAPC");
            return 0;
        }
    }

    // 4. Wait for event to become signalled
    SIZE_T result = 0;
    while (result < bufferSize)
    {
        DWORD index = WaitForMultipleObjects(threadCount, sourceHandles, FALSE, 3000);
        if (index == WAIT_TIMEOUT)
            break;

        buffer[result] = threadHandles[index];
        result++;
    }

    // 6. Close source + target handles
    for (int i = 0; i < threadCount; i++)
    {
        CloseHandle(sourceHandles[i]);

        bool found = false;
        for (int j = 0; j < result && !found; j++)
        {
            if (buffer[j] == threadHandles[i])
                found = true;
        }

        if (!found)
            CloseHandle(threadHandles[i]);
    }

    CloseHandle(snapshot);

    return result;
}

COMMONUTILS_API DWORD PrintLastError(const char* name)
{
	//Get the error message ID, if any.
	DWORD errorMessageID = ::GetLastError();
	if (errorMessageID == 0) {
		return 0;
	}

	LPSTR messageBuffer = nullptr;

	//Ask Win32 to give us the string version of that message ID.
	//The parameters we pass in, tell Win32 to create the buffer that holds the message for us (because we don't yet know how long the message string will be).
	size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);

	printf("%s: %s\n", name, messageBuffer);

	//Free the Win32's string's buffer.
	LocalFree(messageBuffer);
	return 1;
}

char* ReadFileContents(const char* fileName, OUT PDWORD size)
{
	auto fileHandle = CreateFileA(fileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (fileHandle == INVALID_HANDLE_VALUE)
	{
		PrintLastError("CreateFile");
		return 0;
	}

	auto fileSize = GetFileSize(fileHandle, NULL);
	auto fileBuffer = (char*) malloc(fileSize);
	if (!ReadFile(fileHandle, fileBuffer, fileSize, &fileSize, NULL))
	{
		PrintLastError("ReadFile");
		CloseHandle(fileHandle);
		free(fileBuffer);
		return 0;
	}

	if (size != NULL)
		*size = fileSize;

	CloseHandle(fileHandle);
	return fileBuffer;
}