#pragma once

#include "common.h"
#include <Windows.h>

#include "pch.h"
#include "processutils.h"
#include <stdio.h>
#include <TlHelp32.h>
#include <stdlib.h>

DWORD FindProcessIdByName(const wchar_t* name);
HANDLE OpenProcessByName(const wchar_t* name);
SIZE_T FindAlertableThreads(HANDLE processHandle, DWORD pid, PHANDLE buffer, SIZE_T bufferSize);
DWORD PrintLastError(const char* name);
DWORD PrintError(const char* name, DWORD errorMessageID);
char* ReadFileContents(const char* fileName, OUT PDWORD size);
wchar_t* WriteToTempFile(const wchar_t* fileName, LPVOID buffer, SIZE_T bufferSize);

DWORD FindProcessIdByName(const wchar_t* name)
{
    auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE)
        return 0;

    PROCESSENTRY32 entry = {};
    entry.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(snapshot, &entry))
    {
        CloseHandle(snapshot);
        return 0;
    }

    DWORD result = 0;
    do
    {
        if (lstrcmpW(name, entry.szExeFile) == 0) {
            result = entry.th32ProcessID;
        }
    } while (result == 0 && Process32Next(snapshot, &entry));

    CloseHandle(snapshot);
    return result;
}

HANDLE OpenProcessByName(const wchar_t* name)
{
    DWORD id = FindProcessIdByName(name);
    if (id == 0)
        return INVALID_HANDLE_VALUE;

    return OpenProcess(PROCESS_ALL_ACCESS, false, id);
}


SIZE_T FindThreads(DWORD pid, PHANDLE buffer, SIZE_T bufferSize)
{
    auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (snapshot == INVALID_HANDLE_VALUE)
        return NULL;

    THREADENTRY32 entry;
    entry.dwSize = sizeof(THREADENTRY32);
    SIZE_T threadCount = 0;

    if (!Thread32First(snapshot, &entry))
        return NULL;

    do
    {
        if (entry.th32OwnerProcessID != pid)
            continue;

        auto threadHandle = OpenThread(
            THREAD_ALL_ACCESS,
            FALSE,
            entry.th32ThreadID);

        if (threadHandle == NULL)
            continue;

        buffer[threadCount++] = threadHandle;
    } while (threadCount < bufferSize && Thread32Next(snapshot, &entry));

    return threadCount;
}

SIZE_T FindAlertableThreads(HANDLE processHandle, DWORD pid, PHANDLE buffer, SIZE_T bufferSize)
{
    HANDLE sourceHandles[MAXIMUM_WAIT_OBJECTS] = {};
    HANDLE targetHandles[MAXIMUM_WAIT_OBJECTS] = {};
    HANDLE threadHandles[MAXIMUM_WAIT_OBJECTS] = {};

    // 1. Enumerate threads in target process
    auto snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (snapshot == INVALID_HANDLE_VALUE)
        return NULL;

    THREADENTRY32 entry;
    entry.dwSize = sizeof(THREADENTRY32);
    int threadCount = 0;

    if (!Thread32First(snapshot, &entry))
        return NULL;

    do
    {
        // if not our target process, skip it
        if (entry.th32OwnerProcessID != pid)
            continue;

        // if we can't open thread, skip it
        auto threadHandle = OpenThread(
            THREAD_ALL_ACCESS,
            FALSE,
            entry.th32ThreadID);

        if (threadHandle == NULL)
            continue;

        // otherwise, add to list
        threadHandles[threadCount++] = threadHandle;

    } while (threadCount < MAXIMUM_WAIT_OBJECTS && Thread32Next(snapshot, &entry));

    // Resolve address of SetEvent
    auto setEvent = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "SetEvent");

    for (int i = 0; i < threadCount; i++)
    {
        // 2. create event and duplicate in target process
        sourceHandles[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!DuplicateHandle(
            GetCurrentProcess(),
            sourceHandles[i],
            processHandle,
            &targetHandles[i],
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS))
        {
            PrintLastError("DuplicateHandle");
            return 0;
        }

        if (!QueueUserAPC((PAPCFUNC)setEvent, threadHandles[i], (ULONG_PTR)targetHandles[i]))
        {
            PrintLastError("QueueUserAPC");
            return 0;
        }
    }

    // 4. Wait for event to become signalled
    SIZE_T result = 0;
    while (result < bufferSize)
    {
        DWORD index = WaitForMultipleObjects(threadCount, sourceHandles, FALSE, 3000);
        if (index == WAIT_TIMEOUT)
            break;

        buffer[result] = threadHandles[index];
        result++;
    }

    // 6. Close source + target handles
    for (int i = 0; i < threadCount; i++)
    {
        CloseHandle(sourceHandles[i]);

        bool found = false;
        for (int j = 0; j < result && !found; j++)
        {
            if (buffer[j] == threadHandles[i])
                found = true;
        }

        if (!found)
            CloseHandle(threadHandles[i]);
    }

    CloseHandle(snapshot);

    return result;
}

DWORD PrintLastError(const char* name)
{
    return PrintError(name, ::GetLastError());
}

DWORD PrintError(const char* name, DWORD errorMessageID)
{
    LPSTR messageBuffer = nullptr;

    //Ask Win32 to give us the string version of that message ID.
    //The parameters we pass in, tell Win32 to create the buffer that holds the message for us (because we don't yet know how long the message string will be).
    size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);

    printf("%s: %s\n", name, messageBuffer);

    //Free the Win32's string's buffer.
    LocalFree(messageBuffer);
    return 1;
}

char* ReadFileContents(const char* fileName, OUT PDWORD size)
{
    auto fileHandle = CreateFileA(fileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE)
    {
        PrintLastError("CreateFile");
        return 0;
    }

    auto fileSize = GetFileSize(fileHandle, NULL);
    auto fileBuffer = (char*)malloc(fileSize);
    if (!ReadFile(fileHandle, fileBuffer, fileSize, &fileSize, NULL))
    {
        PrintLastError("ReadFile");
        CloseHandle(fileHandle);
        free(fileBuffer);
        return 0;
    }

    if (size != NULL)
        *size = fileSize;

    CloseHandle(fileHandle);
    return fileBuffer;
}

wchar_t* WriteToTempFile(const wchar_t* fileName, LPVOID buffer, SIZE_T bufferSize)
{
    wchar_t tempPath[MAX_PATH] = {};
    wchar_t* finalpath = (wchar_t*) calloc(MAX_PATH, sizeof(wchar_t));

    if (GetTempPathW(MAX_PATH, tempPath) == 0)
    {
        free(finalpath);
        PrintLastError("GetTempPathW");
        return NULL;
    }

    wsprintfW(finalpath, L"%s\\%s", tempPath, fileName);

    auto fileHandle = CreateFile(finalpath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE)
    {
        free(finalpath);
        PrintLastError("CreateFile");
        return NULL;
    }

    DWORD written;
    if (!WriteFile(fileHandle, buffer, bufferSize, &written, NULL))
    {
        free(finalpath);
        PrintLastError("WriteFile");
        return NULL;
    }

    CloseHandle(fileHandle);

    return finalpath;
}
